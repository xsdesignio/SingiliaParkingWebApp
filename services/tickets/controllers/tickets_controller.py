from services.zones.models.zone_model import ZoneModel
from services.zones.entities.zone import Zone
from services.users.entities.user import User
from ..models.ticket_model import TicketModel
from datetime import datetime
from decimal import Decimal

from ..models.available_ticket_model import AvailableTicketModel



def get_tickets_attributes_count(start_date: datetime = None, end_date: datetime = None, zone: Zone = None, user: User = None) -> dict:
    """Return a dictionary with the variables and their count
    
    Keyword arguments:
    start_date -- the start of the period counted
    end_date -- the end of the period counted
    zone -- the zone where the tickets were created
    user -- the user who created the ticket
    Return: a dict containing the amount of each available ticket printed
    """
    query_dict = {}

    # Check the params and add them to the query dict when introduced
    if start_date: query_dict["start_date"] = start_date
    if end_date: query_dict["end_date"] = end_date
    if zone : query_dict["zone_id"] = zone.id
    if user: query_dict["responsible_id"] = user.id

    # Count the amount of tickets paid by card and by cash based on the query dict
    paid_by_card = TicketModel.count_tickets(
        **query_dict, 
        payment_method = "CARD"
    )
    paid_by_cash = TicketModel.count_tickets(
        **query_dict, 
        payment_method = "CASH"
    )

    ## The result dict object with the tickets report data
    result_dict = {
        "tickets_amount": paid_by_card + paid_by_cash,
        "paid_by_card": paid_by_card,
        "income_by_card": Decimal("0.00"),
        "paid_by_cash": paid_by_cash,
        "income_by_cash":  Decimal("0.00"),
        "data_by_duration": [],
        "total_income": Decimal("0.00")
    }

    # Get available tickets using AvailableTicketModel
    available_tickets: list[dict] = AvailableTicketModel.get_available_tickets()
    
    # Add report data from all available tickets and count total income during the process 
    for available_ticket in available_tickets:
        
        data_by_duration_dict = get_available_ticket_attributes_count(
            available_ticket["duration"],
            available_ticket["price"],
            query_dict
        )
        
        # Add the data from the available ticket into the result dict
        result_dict["data_by_duration"].append(data_by_duration_dict)

        result_dict["income_by_card"] += data_by_duration_dict["income_by_card"]
        result_dict["income_by_cash"] += data_by_duration_dict["income_by_cash"]

        # Actualize the total income to add the income generated by this available ticket
        result_dict["total_income"] += data_by_duration_dict["total_income"]

    
    return result_dict


def get_available_ticket_attributes_count(duration, price, query_dict):
    count_by_duration = TicketModel.count_tickets(**query_dict, duration = duration)
        
    paid_by_card = TicketModel.count_tickets(**query_dict, duration = duration, payment_method = "CARD")
    paid_by_cash = TicketModel.count_tickets(**query_dict, duration = duration, payment_method = "CASH")

    if count_by_duration == None:
        count_by_duration = 0

    # Dict with the available ticket data
    return {
        "duration": duration,
        "price": price,
        "amount": count_by_duration,
        "paid_by_card": paid_by_card,
        "income_by_card": paid_by_card * price,
        "paid_by_cash": paid_by_cash,
        "income_by_cash": paid_by_cash * price,
        "total_income": count_by_duration * price,
    }

